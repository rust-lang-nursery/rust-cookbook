# Application development

| Recipe | Crates | Categories |
|--------|--------|------------|
| [Parse command line arguments][ex-clap-basic] | [![clap-badge]][clap] | [![cat-command-line-badge]][cat-command-line] |
| [Decompress a tarball][ex-tar-decompress] | [![flate2-badge]][flate2] [![tar-badge]][tar] | [![cat-compression-badge]][cat-compression] |
| [Compress a directory into a tarball][ex-tar-compress] | [![flate2-badge]][flate2] [![tar-badge]][tar] | [![cat-compression-badge]][cat-compression] |
| [Recursively find duplicate file names][ex-dedup-filenames] | [![walkdir-badge]][walkdir] | [![cat-filesystem-badge]][cat-filesystem] |
| [Recursively find all files with given predicate][ex-file-predicate] | [![walkdir-badge]][walkdir] | [![cat-filesystem-badge]][cat-filesystem] |
| [Recursively calculate file sizes at given depth][ex-file-sizes] | [![walkdir-badge]][walkdir] | [![cat-filesystem-badge]][cat-filesystem] |

[ex-clap-basic]: #ex-clap-basic
<a name="ex-clap-basic"></a>
## Parse command line arguments

[![clap-badge]][clap] [![cat-command-line-badge]][cat-command-line]

```rust
extern crate clap;

use clap::{Arg, App};

fn main() {
    // Define command line arguments.
    let matches = App::new("My Test Program")
        .version("0.1.0")
        .author("Hackerman Jones <hckrmnjones@hack.gov>")
        .about("Teaches argument parsing")
        .arg(Arg::with_name("file")
                 .short("f")
                 .long("file")
                 .takes_value(true)
                 .help("A cool file"))
        .arg(Arg::with_name("num")
                 .short("n")
                 .long("number")
                 .takes_value(true)
                 .help("Five less than your favorite number"))
        .get_matches();

    // Get value for file, or default to 'input.txt'.
    let myfile = matches.value_of("file").unwrap_or("input.txt");
    println!("The file passed is: {}", myfile);

    // Get value for num if present, and try parsing it as i32.
    let num_str = matches.value_of("num");
    match num_str {
        None => println!("No idea what your favorite number is."),
        Some(s) => {
            match s.parse::<i32>() {
                Ok(n) => println!("Your favorite number must be {}.", n + 5),
                Err(_) => println!("That's not a number! {}", s),
            }
        }
    }
}
```

The `clap` crate is a simple-to-use, efficient, and full-featured library for
parsing command line arguments and subcommands when writing console/terminal
applications.

The application can describe the structure of its command-line interface using
`clap`'s builder style. The [documentation] gives two other possible ways to
instantiate an application.

[documentation]: https://docs.rs/clap/

In the builder style, `with_name` is the unique identifier that `value_of` will
use to retrieve the value passed. The `short` and `long` options control the
flag the user will be expected to type; short flags look like `-f` and long
flags look like `--file`.

Usage information is generated by `clap`. The usage for the example application
looks like this.

```
My Test Program 0.1.0
Hackerman Jones <hckrmnjones@hack.gov>
Teaches argument parsing

USAGE:
    testing [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -f, --file <file>     A cool file
    -n, --number <num>    Five less than your favorite number
```

We can test the application by running a command like the following.

```
$ cargo run -- -f myfile.txt -n 251
```

The output is:

```
The file passed is: myfile.txt
Your favorite number must be 256.
```

[ex-tar-decompress]: #ex-tar-decompress
<a name="ex-tar-decompress"></a>
## Decompress a tarball

[![flate2-badge]][flate2] [![tar-badge]][tar] [![cat-compression-badge]][cat-compression]

Decompress ([`flate2::read::GzDecoder::new`]) and
extract ([`tar::Archive::unpack`]) all files from a compressed tarball
named `archive.tar.gz` located in the current working directory.

```rust,no_run
# #[macro_use]
# extern crate error_chain;
extern crate flate2;
extern crate tar;

use std::fs::File;
use flate2::read::GzDecoder;
use tar::Archive;
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#     }
# }

fn run() -> Result<()> {
    let path = "archive.tar.gz";

    // Open a compressed tarball
    let tar_gz = File::open(path)?;
    // Decompress it
    let tar = GzDecoder::new(tar_gz)?;
    // Load the archive from the tarball
    let mut archive = Archive::new(tar);
    // Unpack the archive inside curent working directory
    archive.unpack(".")?;

    Ok(())
}
#
# quick_main!(run);
```

[ex-tar-compress]: #ex-tar-compress
<a name="ex-tar-compress"></a>
## Compress a directory into tarball

[![flate2-badge]][flate2] [![tar-badge]][tar] [![cat-compression-badge]][cat-compression]

Compresses `/var/log` directory into `archive.tar.gz`.

Creates a [`File`] wrapped in [`flate2::write::GzEncoder`]
and [`tar::Builder`]. </br>Adds contents of `/var/log` directory recursively into the archive
under `backup/logs`path with [`Builder::append_dir_all`].
[`flate2::write::GzEncoder`] is responsible for transparently compressing the
data prior to writing it into `archive.tar.gz`.

```rust,no_run
# #[macro_use]
# extern crate error_chain;
extern crate tar;
extern crate flate2;
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#     }
# }

use std::fs::File;
use flate2::Compression;
use flate2::write::GzEncoder;

fn run() -> Result<()> {
    let tar_gz = File::create("archive.tar.gz")?;
    let enc = GzEncoder::new(tar_gz, Compression::Default);
    let mut tar = tar::Builder::new(enc);
    tar.append_dir_all("backup/logs", "/var/log")?;
    Ok(())
}
#
# quick_main!(run);
```

[ex-dedup-filenames]: #ex-dedup-filenames
<a name="ex-dedup-filenames"></a>
## Recursively find duplicate file names

[![walkdir-badge]][walkdir] [![cat-filesystem-badge]][cat-filesystem]

Find recusively in the current directory duplicate filenames,
printing them only once.

```rust,no_run
extern crate walkdir;

use std::collections::HashMap;
use walkdir::WalkDir;

fn main() {
    // Counters indexed by filenames
    let mut filenames = HashMap::new();

    // List recusively all files in the current directory filtering out
    // directories and files not accessible (permission denied)
    for entry in WalkDir::new(".")
            .into_iter()
            .filter_map(Result::ok)
            .filter(|e| !e.file_type().is_dir()) {
        // Get entry's filename
        let f_name = String::from(entry.file_name().to_string_lossy());
        // Get or initialize the counter
        let counter = filenames.entry(f_name.clone()).or_insert(0);
        // Update the counter
        *counter += 1;

        if *counter == 2 {
            println!("{}", f_name);
        }
    }
}
```

[ex-file-predicate]: #ex-file-predicate
<a name="ex-file-predicate"></a>
##  Recursively find all files with given predicate

Use the file names and metadata to recursively find in the current directory JSON files modified within the last day.

[![walkdir-badge]][walkdir] [![cat-filesystem-badge]][cat-filesystem]

```rust,no_run
# #[macro_use]
# extern crate error_chain;
extern crate walkdir;

use walkdir::WalkDir;
#
# error_chain! {
#     foreign_links {
#         WalkDir(walkdir::Error);
#         Io(std::io::Error);
#         SystemTime(std::time::SystemTimeError);
#     }
# }

fn run() -> Result<()> {
    // List recusively all accessible files in the current directory
    for entry in WalkDir::new(".").into_iter().filter_map(|e| e.ok()) {
        // Get entry's filename
        let f_name = entry.file_name().to_string_lossy();
        // Get entry's modified time
        let sec = entry.metadata()?.modified()?;

        // Print JSON files modified within the last day
        if f_name.ends_with(".json") && sec.elapsed()?.as_secs() < 86400 {
            println!("{}", f_name);
        }
    }

    Ok(())
}
#
# quick_main!(run);
```

[ex-file-sizes]: #ex-file-sizes
<a name="ex-file-sizes"></a>
## Recursively calculate file sizes at given depth

Recursion depth can be flexibly set by [`WalkDir::min_depth`] & [`WalkDir::max_depth`] methods.
In this example we sum all file sizes to 3 subfolders depth, ignoring files in the root folder
at the same time.

[![walkdir-badge]][walkdir] [![cat-filesystem-badge]][cat-filesystem]

```rust
extern crate walkdir;

use walkdir::WalkDir;

fn main() {
    let total_size = WalkDir::new(".")
        .min_depth(1)
        .max_depth(3)
        .into_iter()
        .filter_map(|entry| entry.ok()) // Files, we have access to
        .filter_map(|entry| entry.metadata().ok()) // Get metadata
        .filter(|metadata| metadata.is_file()) // Filter out directories
        .fold(0, |acc, m| acc + m.len()); // Accumulate sizes

    println!("Total size: {} bytes.", total_size);
}
```

<!-- Categories -->

[cat-command-line-badge]: https://badge-cache.kominick.com/badge/command_line--x.svg?style=social
[cat-command-line]: https://crates.io/categories/command-line-interface
[cat-compression-badge]: https://badge-cache.kominick.com/badge/compression--x.svg?style=social
[cat-compression]: https://crates.io/categories/compression
[cat-filesystem-badge]: https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social
[cat-filesystem]: https://crates.io/categories/filesystem

<!-- Crates -->

[clap-badge]: https://badge-cache.kominick.com/crates/v/clap.svg?label=clap
[clap]: https://docs.rs/clap/
[flate2-badge]: https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2
[flate2]: https://docs.rs/flate2/
[tar-badge]: https://badge-cache.kominick.com/crates/v/tar.svg?label=tar
[tar]: https://docs.rs/tar/
[walkdir-badge]: https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir
[walkdir]: https://docs.rs/walkdir/

<!-- Reference -->

[`File`]: https://doc.rust-lang.org/std/fs/struct.File.html
[`flate2::read::GzDecoder::new`]: https://docs.rs/flate2/*/flate2/read/struct.GzDecoder.html#method.new
[`flate2::write::GzEncoder`]: https://docs.rs/flate2/*/flate2/write/struct.GzEncoder.html
[`tar::Archive::unpack`]: https://docs.rs/tar/*/tar/struct.Archive.html#method.unpack
[`tar::Builder`]: https://docs.rs/tar/*/tar/struct.Builder.html
[`Builder::append_dir_all`]: https://docs.rs/tar/*/tar/struct.Builder.html#method.append_dir_all
[`WalkDir::min_depth`]: https://docs.rs/walkdir/*/walkdir/struct.WalkDir.html#method.min_depth
[`WalkDir::max_depth`]: https://docs.rs/walkdir/*/walkdir/struct.WalkDir.html#method.max_depth
