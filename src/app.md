# Application development

| Recipe | Crates | Categories |
|--------|--------|------------|
| [Parse command line arguments][ex-clap-basic] | [![clap-badge]][clap] | [![cat-command-line-badge]][cat-command-line] |
| [Log messages to the console][ex-log-messages] | [![log-badge]][log] | [![cat-debugging-badge]][cat-debugging] |
| [Enable log levels per module][ex-log-mod] | [![log-badge]][log] [![env_logger-badge]][env_logger] | [![cat-command-line-badge]][cat-command-line] |
| [Log to the Unix syslog][ex-log-syslog] | [![log-badge]][log] [![syslog-badge]][syslog] | [![cat-debugging-badge]][cat-debugging] |
| [Log messages to a custom location][ex-log-custom] | [![log-badge]][log] | [![cat-command-line-badge]][cat-command-line] |

[ex-clap-basic]: #ex-clap-basic
<a name="ex-clap-basic"></a>
## Parse command line arguments

[![clap-badge]][clap] [![cat-command-line-badge]][cat-command-line]

```rust
extern crate clap;

use clap::{Arg, App};

fn main() {
    // Define command line arguments.
    let matches = App::new("My Test Program")
        .version("0.1.0")
        .author("Hackerman Jones <hckrmnjones@hack.gov>")
        .about("Teaches argument parsing")
        .arg(Arg::with_name("file")
                 .short("f")
                 .long("file")
                 .takes_value(true)
                 .help("A cool file"))
        .arg(Arg::with_name("num")
                 .short("n")
                 .long("number")
                 .takes_value(true)
                 .help("Five less than your favorite number"))
        .get_matches();

    // Get value for file, or default to 'input.txt'.
    let myfile = matches.value_of("file").unwrap_or("input.txt");
    println!("The file passed is: {}", myfile);

    // Get value for num if present, and try parsing it as i32.
    let num_str = matches.value_of("num");
    match num_str {
        None => println!("No idea what your favorite number is."),
        Some(s) => {
            match s.parse::<i32>() {
                Ok(n) => println!("Your favorite number must be {}.", n + 5),
                Err(_) => println!("That's not a number! {}", s),
            }
        }
    }
}
```

The `clap` crate is a simple-to-use, efficient, and full-featured library for
parsing command line arguments and subcommands when writing console/terminal
applications.

The application can describe the structure of its command-line interface using
`clap`'s builder style. The [documentation] gives two other possible ways to
instantiate an application.

[documentation]: https://docs.rs/clap/

In the builder style, `with_name` is the unique identifier that `value_of` will
use to retrieve the value passed. The `short` and `long` options control the
flag the user will be expected to type; short flags look like `-f` and long
flags look like `--file`.

Usage information is generated by `clap`. The usage for the example application
looks like this.

```
My Test Program 0.1.0
Hackerman Jones <hckrmnjones@hack.gov>
Teaches argument parsing

USAGE:
    testing [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -f, --file <file>     A cool file
    -n, --number <num>    Five less than your favorite number
```

We can test the application by running a command like the following.

```
$ cargo run -- -f myfile.txt -n 251
```

The output is:

```
The file passed is: myfile.txt
Your favorite number must be 256.
```

[ex-log-messages]: #ex-log-messages
<a name="ex-log-messages"></a>
## Log messages to the console

[![log-badge]][log] [![cat-command-line-badge]][cat-command-line]

```rust
#[macro_use]
extern crate log;

use log::{LogRecord, LogLevel, LogMetadata, LogLevelFilter, SetLoggerError};

struct ConsoleLogger;

impl log::Log for ConsoleLogger {
    fn enabled(&self, metadata: &LogMetadata) -> bool {
        metadata.level() <= LogLevel::Info
    }

    fn log(&self, record: &LogRecord) {
        if self.enabled(record.metadata()) {
            println!("{} - {}", record.level(), record.args());
        }
    }
}

fn run() -> Result<(), SetLoggerError> {
    log::set_logger(|max_log_level| {
                        max_log_level.set(LogLevelFilter::Info);
                        Box::new(ConsoleLogger)
                    })?;
    
    info!("hello log");
    warn!("warning");
    error!("oops");
    Ok(())
}

fn main() {
    run().unwrap();
}
```

[ex-log-mod]: #ex-log-mod
<a name="ex-log-mod"></a>
## Enable log levels per module

[![log-badge]][log] [![env_logger-badge]][env_logger] [![cat-command-line-badge]][cat-command-line]

[Write me!](https://github.com/brson/rust-cookbook/issues/61)

[ex-log-syslog]: #ex-log-syslog
<a name="ex-log-syslog"></a>
## Log to the Unix syslog

[![log-badge]][log] [![syslog-badge]][syslog] [![cat-debugging-badge]][cat-debugging]

Messages are logged to [UNIX syslog]. Logger backend is initialized
with [`syslog::init`].
[`syslog::Facility`] indicates type of program submitting log.
[`log::LogLevelFilter`] denotes allowed log verbosity
and `Option<&str>` holds optional application name.

```rust,no_run
#[macro_use] extern crate log;
extern crate syslog;

use log::{LogLevelFilter, SetLoggerError};
use syslog::Facility;


fn run() -> Result<(), SetLoggerError> {
    syslog::init(Facility::LOG_USER, LogLevelFilter::Debug, Some("My app name"))?;
    debug!("this is a debug {}", "message");
    error!("this is an error!");
    Ok(())
}

fn main() {
    run().unwrap();
}
```

[ex-log-custom]: #ex-log-custom
<a name="ex-log-custom"></a>
## Log messages to a custom location

[![log-badge]][log] [![cat-command-line-badge]][cat-command-line]

[Write me!](https://github.com/brson/rust-cookbook/issues/61)


<!-- Categories -->

[cat-command-line-badge]: https://img.shields.io/badge/-command_line-red.svg
[cat-command-line]: https://crates.io/categories/command-line-interface
[cat-debugging-badge]: https://img.shields.io/badge/-debugging-red.svg
[cat-debugging]: https://crates.io/categories/debugging

<!-- Crates -->

[clap-badge]: https://img.shields.io/crates/v/clap.svg?label=clap
[clap]: https://docs.rs/clap/
[env_logger-badge]: https://img.shields.io/crates/v/clap.svg?label=env_logger
[env_logger]: https://docs.rs/env_logger/
[log-badge]: https://img.shields.io/crates/v/clap.svg?label=log
[log]: https://docs.rs/log/
[log_syslog-badge]: https://img.shields.io/crates/v/clap.svg?label=log_syslog
[log_syslog]: https://docs.rs/log_syslog/
[syslog-badge]: https://img.shields.io/crates/v/syslog.svg?label=syslog
[syslog]: https://docs.rs/syslog/

<!-- Reference -->

[`syslog::init`]: https://docs.rs/syslog/*/syslog/fn.init.html
[`syslog::Facility`]: https://docs.rs/syslog/*/syslog/enum.Facility.html
[`log::LogLevelFilter`]: https://doc.rust-lang.org/log/log/enum.LogLevelFilter.html
[UNIX syslog]: https://www.gnu.org/software/libc/manual/html_node/Overview-of-Syslog.html
